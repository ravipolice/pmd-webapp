"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(dashboard)/documents/page",{

/***/ "(app-pages-browser)/./lib/services/documents.service.ts":
/*!*******************************************!*\
  !*** ./lib/services/documents.service.ts ***!
  \*******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDocument: () => (/* binding */ deleteDocument),\n/* harmony export */   fetchDocuments: () => (/* binding */ fetchDocuments),\n/* harmony export */   getDownloadUrl: () => (/* binding */ getDownloadUrl),\n/* harmony export */   getPreviewUrl: () => (/* binding */ getPreviewUrl)\n/* harmony export */ });\n/**\r\n * Documents Service\r\n * Handles fetching and normalizing documents from Apps Script API\r\n * \r\n * âœ… Normalization happens here (single source of truth)\r\n * âœ… API shape decoupled from UI\r\n * âœ… Backend changes won't break UI\r\n */ /**\r\n * Fetch documents from both Firestore and Apps Script API\r\n * Merges and normalizes the response to a consistent format\r\n */ async function fetchDocuments() {\n    try {\n        // Fetch from Firestore first\n        let firestoreDocs = [];\n        try {\n            const { getDocumentsList } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @/lib/firebase/firestore */ \"(app-pages-browser)/./lib/firebase/firestore.ts\"));\n            const fsDocs = await getDocumentsList();\n            firestoreDocs = fsDocs.map((doc)=>{\n                var _doc_createdAt, _doc_createdAt1;\n                return {\n                    id: doc.id,\n                    title: doc.title || doc.name || \"Untitled Document\",\n                    url: doc.url || doc.URL || \"\",\n                    category: doc.category || doc.Category,\n                    uploadedBy: doc.uploadedBy || doc.UploadedBy,\n                    uploadedDate: doc.uploadedDate || doc.UploadedDate || (((_doc_createdAt = doc.createdAt) === null || _doc_createdAt === void 0 ? void 0 : _doc_createdAt.toDate) ? doc.createdAt.toDate().toISOString() : undefined),\n                    description: doc.description || doc.Description,\n                    fileId: doc.fileId,\n                    fileType: doc.fileType || doc.type,\n                    name: doc.name || doc.title,\n                    type: doc.type || doc.fileType,\n                    createdAt: ((_doc_createdAt1 = doc.createdAt) === null || _doc_createdAt1 === void 0 ? void 0 : _doc_createdAt1.toDate) ? doc.createdAt.toDate() : doc.createdAt ? new Date(doc.createdAt) : undefined\n                };\n            });\n            console.log(\"Found \".concat(firestoreDocs.length, \" documents in Firestore\"));\n        } catch (error) {\n            console.warn(\"Error fetching from Firestore:\", (error === null || error === void 0 ? void 0 : error.message) || \"Unknown\");\n        }\n        // Fetch from Apps Script API\n        let apiDocs = [];\n        try {\n            const apiUrl = \"/api/documents\";\n            console.log(\"Fetching from API route:\", apiUrl);\n            const response = await fetch(apiUrl, {\n                method: \"GET\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                cache: \"no-store\"\n            });\n            console.log(\"API Response Status:\", response.status, response.statusText);\n            console.log(\"API Response OK:\", response.ok);\n            if (response.ok) {\n                const data = await response.json();\n                console.log(\"API Response Data Type:\", Array.isArray(data) ? \"array\" : typeof data);\n                console.log(\"API Response Data:\", data);\n                // Handle both array and object responses\n                apiDocs = Array.isArray(data) ? data : (data === null || data === void 0 ? void 0 : data.data) || (data === null || data === void 0 ? void 0 : data.documents) || (data === null || data === void 0 ? void 0 : data.items) || [];\n                console.log(\"Found \".concat(apiDocs.length, \" documents from Apps Script API\"));\n            } else {\n                const errorText = await response.text().catch(()=>\"Could not read error\");\n                console.error(\"API Route Error Response:\", response.status, errorText);\n            }\n        } catch (error) {\n            console.error(\"Error fetching from Apps Script API:\", (error === null || error === void 0 ? void 0 : error.message) || \"Unknown\");\n            console.error(\"Error details:\", {\n                name: error === null || error === void 0 ? void 0 : error.name,\n                message: error === null || error === void 0 ? void 0 : error.message,\n                stack: error === null || error === void 0 ? void 0 : error.stack\n            });\n        }\n        // Combine both sources (Firestore takes precedence for duplicates by URL)\n        const allDocs = [\n            ...firestoreDocs,\n            ...apiDocs\n        ];\n        // Remove duplicates by URL (prefer Firestore entries)\n        const uniqueDocs = new Map();\n        firestoreDocs.forEach((doc)=>{\n            if (doc.url) uniqueDocs.set(doc.url, doc);\n        });\n        apiDocs.forEach((doc)=>{\n            const url = doc.URL || doc.url;\n            if (url && !uniqueDocs.has(url)) {\n                uniqueDocs.set(url, doc);\n            }\n        });\n        const rawDocs = Array.from(uniqueDocs.values());\n        if (!Array.isArray(rawDocs)) {\n            console.warn(\"Combined documents is not an array\");\n            return [];\n        }\n        // ðŸ”¥ NORMALIZATION HAPPENS HERE (ONLY ONCE)\n        const normalized = rawDocs.map((doc)=>{\n            // Filter out deleted documents\n            const deleteStatus = doc.Delete || doc.delete || \"\";\n            if (deleteStatus.toString().toLowerCase() === \"deleted\") {\n                return null;\n            }\n            // Normalize field names - Apps Script uses Title/URL, we use title/url\n            const normalized = {\n                id: doc.id || doc.fileId || undefined,\n                // Map Title -> title (Apps Script format to our format)\n                title: doc.Title || doc.title || doc.name || \"Untitled Document\",\n                // Map URL -> url\n                url: doc.URL || doc.url || \"\",\n                // Map Category -> category\n                category: doc.Category || doc.category || undefined,\n                // Map UploadedBy -> uploadedBy\n                uploadedBy: doc.UploadedBy || doc.uploadedBy || undefined,\n                // Map UploadedDate -> uploadedDate\n                uploadedDate: doc.UploadedDate || doc.uploadedDate || undefined,\n                // Map Description -> description\n                description: doc.Description || doc.description || undefined,\n                // Keep fileId and fileType as-is\n                fileId: doc.fileId || undefined,\n                fileType: doc.fileType || undefined,\n                // For compatibility with existing Document interface\n                name: doc.Title || doc.title || doc.name || \"Untitled Document\",\n                type: doc.fileType || doc.Category || doc.category || undefined,\n                // Parse UploadedDate to Date if available\n                createdAt: doc.UploadedDate ? new Date(doc.UploadedDate) : doc.createdAt ? doc.createdAt.toDate ? doc.createdAt.toDate() : new Date(doc.createdAt) : undefined\n            };\n            return normalized;\n        }).filter((doc)=>doc !== null); // Remove null entries (deleted documents)\n        // Sort by date (newest first)\n        normalized.sort((a, b)=>{\n            var _a_createdAt, _b_createdAt;\n            const aDate = ((_a_createdAt = a.createdAt) === null || _a_createdAt === void 0 ? void 0 : _a_createdAt.getTime()) || (a.uploadedDate ? new Date(a.uploadedDate).getTime() : 0);\n            const bDate = ((_b_createdAt = b.createdAt) === null || _b_createdAt === void 0 ? void 0 : _b_createdAt.getTime()) || (b.uploadedDate ? new Date(b.uploadedDate).getTime() : 0);\n            return bDate - aDate; // Descending order (newest first)\n        });\n        return normalized;\n    } catch (error) {\n        console.error(\"Error fetching documents:\", error);\n        throw new Error(\"Failed to fetch documents: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"Unknown error\"));\n    }\n}\n/**\r\n * Delete a document via Apps Script API\r\n * @param title - Document title (required by Apps Script)\r\n * @param userEmail - User email for logging\r\n */ async function deleteDocument(title, userEmail, fileId) {\n    try {\n        const response = await fetch(\"/api/documents\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                action: \"deleteDocument\",\n                title: title,\n                fileId: fileId,\n                userEmail: userEmail\n            })\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({\n                    error: \"Unknown error\"\n                }));\n            throw new Error(errorData.error || \"Failed to delete document: \".concat(response.status));\n        }\n        const data = await response.json();\n        if (!data.success) {\n            throw new Error(data.error || \"Failed to delete document\");\n        }\n    } catch (error) {\n        console.error(\"Error deleting document:\", error);\n        throw new Error(\"Failed to delete document: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"Unknown error\"));\n    }\n}\n/**\r\n * Get Google Drive preview URL\r\n * Converts various Google Drive URL formats to preview URL\r\n */ function getPreviewUrl(url) {\n    if (!url) return url;\n    // Extract file ID from various Google Drive URL formats\n    let fileId = null;\n    // Pattern 1: /file/d/FILE_ID/view or /file/d/FILE_ID/\n    const match1 = url.match(/\\/file\\/d\\/([-\\w]{25,})/);\n    if (match1) fileId = match1[1];\n    // Pattern 2: ?id=FILE_ID or &id=FILE_ID\n    if (!fileId) {\n        const match2 = url.match(/[?&]id=([-\\w]{25,})/);\n        if (match2) fileId = match2[1];\n    }\n    // Pattern 3: /uc?export=view&id=FILE_ID\n    if (!fileId) {\n        const match3 = url.match(/\\/uc\\?export=view&id=([-\\w]{25,})/);\n        if (match3) fileId = match3[1];\n    }\n    // If we found a file ID, return preview URL\n    if (fileId) {\n        return \"https://drive.google.com/file/d/\".concat(fileId, \"/preview\");\n    }\n    // Otherwise, return original URL\n    return url;\n}\n/**\r\n * Get Google Drive download URL\r\n * Converts various Google Drive URL formats to direct download URL\r\n */ function getDownloadUrl(url) {\n    if (!url) return url;\n    // Extract file ID from various Google Drive URL formats\n    let fileId = null;\n    // Pattern 1: /file/d/FILE_ID/view or /file/d/FILE_ID/\n    const match1 = url.match(/\\/file\\/d\\/([-\\w]{25,})/);\n    if (match1) fileId = match1[1];\n    // Pattern 2: ?id=FILE_ID or &id=FILE_ID\n    if (!fileId) {\n        const match2 = url.match(/[?&]id=([-\\w]{25,})/);\n        if (match2) fileId = match2[1];\n    }\n    // Pattern 3: /uc?export=view&id=FILE_ID\n    if (!fileId) {\n        const match3 = url.match(/\\/uc\\?export=view&id=([-\\w]{25,})/);\n        if (match3) fileId = match3[1];\n    }\n    // If we found a file ID, return download URL\n    if (fileId) {\n        return \"https://drive.google.com/uc?export=download&id=\".concat(fileId);\n    }\n    // Otherwise, return original URL\n    return url;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9zZXJ2aWNlcy9kb2N1bWVudHMuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7Ozs7Q0FPQyxHQTRDRDs7O0NBR0MsR0FDTSxlQUFlQTtJQUNwQixJQUFJO1FBQ0YsNkJBQTZCO1FBQzdCLElBQUlDLGdCQUFnQyxFQUFFO1FBQ3RDLElBQUk7WUFDRixNQUFNLEVBQUVDLGdCQUFnQixFQUFFLEdBQUcsTUFBTSx1S0FBa0M7WUFDckUsTUFBTUMsU0FBUyxNQUFNRDtZQUNyQkQsZ0JBQWdCRSxPQUFPQyxHQUFHLENBQUMsQ0FBQ0M7b0JBTTZCQSxnQkFNNUNBO3VCQVo2QjtvQkFDeENDLElBQUlELElBQUlDLEVBQUU7b0JBQ1ZDLE9BQU9GLElBQUlFLEtBQUssSUFBSUYsSUFBSUcsSUFBSSxJQUFJO29CQUNoQ0MsS0FBS0osSUFBSUksR0FBRyxJQUFJSixJQUFJSyxHQUFHLElBQUk7b0JBQzNCQyxVQUFVTixJQUFJTSxRQUFRLElBQUlOLElBQUlPLFFBQVE7b0JBQ3RDQyxZQUFZUixJQUFJUSxVQUFVLElBQUlSLElBQUlTLFVBQVU7b0JBQzVDQyxjQUFjVixJQUFJVSxZQUFZLElBQUlWLElBQUlXLFlBQVksSUFBS1gsQ0FBQUEsRUFBQUEsaUJBQUFBLElBQUlZLFNBQVMsY0FBYloscUNBQUFBLGVBQWVhLE1BQU0sSUFBR2IsSUFBSVksU0FBUyxDQUFDQyxNQUFNLEdBQUdDLFdBQVcsS0FBS0MsU0FBUTtvQkFDOUhDLGFBQWFoQixJQUFJZ0IsV0FBVyxJQUFJaEIsSUFBSWlCLFdBQVc7b0JBQy9DQyxRQUFRbEIsSUFBSWtCLE1BQU07b0JBQ2xCQyxVQUFVbkIsSUFBSW1CLFFBQVEsSUFBSW5CLElBQUlvQixJQUFJO29CQUNsQ2pCLE1BQU1ILElBQUlHLElBQUksSUFBSUgsSUFBSUUsS0FBSztvQkFDM0JrQixNQUFNcEIsSUFBSW9CLElBQUksSUFBSXBCLElBQUltQixRQUFRO29CQUM5QlAsV0FBV1os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O1FBQ1gsTUFBTWtFLFNBQVNoRixJQUFJOEUsS0FBSyxDQUFDO1FBQ3pCLElBQUlFLFFBQVFsRSxTQUFTa0UsTUFBTSxDQUFDLEVBQUU7SUFDaEM7SUFFQSw0Q0FBNEM7SUFDNUMsSUFBSWxFLFFBQVE7UUFDVixPQUFPLG1DQUEwQyxPQUFQQSxRQUFPO0lBQ25EO0lBRUEsaUNBQWlDO0lBQ2pDLE9BQU9kO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDTSxTQUFTaUYsZUFBZWpGLEdBQVc7SUFDeEMsSUFBSSxDQUFDQSxLQUFLLE9BQU9BO0lBRWpCLHdEQUF3RDtJQUN4RCxJQUFJYyxTQUF3QjtJQUU1QixzREFBc0Q7SUFDdEQsTUFBTStELFNBQVM3RSxJQUFJOEUsS0FBSyxDQUFDO0lBQ3pCLElBQUlELFFBQVEvRCxTQUFTK0QsTUFBTSxDQUFDLEVBQUU7SUFFOUIsd0NBQXdDO0lBQ3hDLElBQUksQ0FBQy9ELFFBQVE7UUFDWCxNQUFNaUUsU0FBUy9FLElBQUk4RSxLQUFLLENBQUM7UUFDekIsSUFBSUMsUUFBUWpFLFNBQVNpRSxNQUFNLENBQUMsRUFBRTtJQUNoQztJQUVBLHdDQUF3QztJQUN4QyxJQUFJLENBQUNqRSxRQUFRO1FBQ1gsTUFBTWtFLFNBQVNoRixJQUFJOEUsS0FBSyxDQUFDO1FBQ3pCLElBQUlFLFFBQVFsRSxTQUFTa0UsTUFBTSxDQUFDLEVBQUU7SUFDaEM7SUFFQSw2Q0FBNkM7SUFDN0MsSUFBSWxFLFFBQVE7UUFDVixPQUFPLGtEQUF5RCxPQUFQQTtJQUMzRDtJQUVBLGlDQUFpQztJQUNqQyxPQUFPZDtBQUNUIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXHJhdmlwXFxBbmRyb2lkU3R1ZGlvUHJvamVjdHNcXHBtZC1hZG1pblxcbGliXFxzZXJ2aWNlc1xcZG9jdW1lbnRzLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERvY3VtZW50cyBTZXJ2aWNlXHJcbiAqIEhhbmRsZXMgZmV0Y2hpbmcgYW5kIG5vcm1hbGl6aW5nIGRvY3VtZW50cyBmcm9tIEFwcHMgU2NyaXB0IEFQSVxyXG4gKiBcclxuICog4pyFIE5vcm1hbGl6YXRpb24gaGFwcGVucyBoZXJlIChzaW5nbGUgc291cmNlIG9mIHRydXRoKVxyXG4gKiDinIUgQVBJIHNoYXBlIGRlY291cGxlZCBmcm9tIFVJXHJcbiAqIOKchSBCYWNrZW5kIGNoYW5nZXMgd29uJ3QgYnJlYWsgVUlcclxuICovXHJcblxyXG5leHBvcnQgdHlwZSBEb2N1bWVudEl0ZW0gPSB7XHJcbiAgaWQ/OiBzdHJpbmc7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICB1cmw6IHN0cmluZztcclxuICBjYXRlZ29yeT86IHN0cmluZztcclxuICB1cGxvYWRlZEJ5Pzogc3RyaW5nO1xyXG4gIHVwbG9hZGVkRGF0ZT86IHN0cmluZztcclxuICBkZXNjcmlwdGlvbj86IHN0cmluZztcclxuICBmaWxlSWQ/OiBzdHJpbmc7XHJcbiAgZmlsZVR5cGU/OiBzdHJpbmc7XHJcbiAgLy8gRm9yIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBEb2N1bWVudCBpbnRlcmZhY2VcclxuICBuYW1lPzogc3RyaW5nO1xyXG4gIHR5cGU/OiBzdHJpbmc7XHJcbiAgY3JlYXRlZEF0PzogRGF0ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSYXcgQVBJIHJlc3BvbnNlIHR5cGUgZnJvbSBBcHBzIFNjcmlwdFxyXG4gKiBBcHBzIFNjcmlwdCByZXR1cm5zOiBUaXRsZSwgVVJMLCBDYXRlZ29yeSwgVXBsb2FkZWRCeSwgVXBsb2FkZWREYXRlLCBEZXNjcmlwdGlvbiwgRGVsZXRlLCBmaWxlSWQsIGZpbGVUeXBlXHJcbiAqL1xyXG50eXBlIFJhd0FwaURvY3VtZW50ID0ge1xyXG4gIFRpdGxlPzogc3RyaW5nO1xyXG4gIHRpdGxlPzogc3RyaW5nO1xyXG4gIG5hbWU/OiBzdHJpbmc7XHJcbiAgVVJMPzogc3RyaW5nO1xyXG4gIHVybD86IHN0cmluZztcclxuICBDYXRlZ29yeT86IHN0cmluZztcclxuICBjYXRlZ29yeT86IHN0cmluZztcclxuICBVcGxvYWRlZEJ5Pzogc3RyaW5nO1xyXG4gIHVwbG9hZGVkQnk/OiBzdHJpbmc7XHJcbiAgVXBsb2FkZWREYXRlPzogc3RyaW5nO1xyXG4gIHVwbG9hZGVkRGF0ZT86IHN0cmluZztcclxuICBEZXNjcmlwdGlvbj86IHN0cmluZztcclxuICBkZXNjcmlwdGlvbj86IHN0cmluZztcclxuICBEZWxldGU/OiBzdHJpbmc7XHJcbiAgZGVsZXRlPzogc3RyaW5nO1xyXG4gIGZpbGVJZD86IHN0cmluZztcclxuICBmaWxlVHlwZT86IHN0cmluZztcclxuICBpZD86IHN0cmluZztcclxuICBjcmVhdGVkQXQ/OiBhbnk7XHJcbn07XHJcblxyXG4vKipcclxuICogRmV0Y2ggZG9jdW1lbnRzIGZyb20gYm90aCBGaXJlc3RvcmUgYW5kIEFwcHMgU2NyaXB0IEFQSVxyXG4gKiBNZXJnZXMgYW5kIG5vcm1hbGl6ZXMgdGhlIHJlc3BvbnNlIHRvIGEgY29uc2lzdGVudCBmb3JtYXRcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaERvY3VtZW50cygpOiBQcm9taXNlPERvY3VtZW50SXRlbVtdPiB7XHJcbiAgdHJ5IHtcclxuICAgIC8vIEZldGNoIGZyb20gRmlyZXN0b3JlIGZpcnN0XHJcbiAgICBsZXQgZmlyZXN0b3JlRG9jczogRG9jdW1lbnRJdGVtW10gPSBbXTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgZ2V0RG9jdW1lbnRzTGlzdCB9ID0gYXdhaXQgaW1wb3J0KFwiQC9saWIvZmlyZWJhc2UvZmlyZXN0b3JlXCIpO1xyXG4gICAgICBjb25zdCBmc0RvY3MgPSBhd2FpdCBnZXREb2N1bWVudHNMaXN0KCk7XHJcbiAgICAgIGZpcmVzdG9yZURvY3MgPSBmc0RvY3MubWFwKChkb2M6IGFueSkgPT4gKHtcclxuICAgICAgICBpZDogZG9jLmlkLFxyXG4gICAgICAgIHRpdGxlOiBkb2MudGl0bGUgfHwgZG9jLm5hbWUgfHwgXCJVbnRpdGxlZCBEb2N1bWVudFwiLFxyXG4gICAgICAgIHVybDogZG9jLnVybCB8fCBkb2MuVVJMIHx8IFwiXCIsXHJcbiAgICAgICAgY2F0ZWdvcnk6IGRvYy5jYXRlZ29yeSB8fCBkb2MuQ2F0ZWdvcnksXHJcbiAgICAgICAgdXBsb2FkZWRCeTogZG9jLnVwbG9hZGVkQnkgfHwgZG9jLlVwbG9hZGVkQnksXHJcbiAgICAgICAgdXBsb2FkZWREYXRlOiBkb2MudXBsb2FkZWREYXRlIHx8IGRvYy5VcGxvYWRlZERhdGUgfHwgKGRvYy5jcmVhdGVkQXQ/LnRvRGF0ZSA/IGRvYy5jcmVhdGVkQXQudG9EYXRlKCkudG9JU09TdHJpbmcoKSA6IHVuZGVmaW5lZCksXHJcbiAgICAgICAgZGVzY3JpcHRpb246IGRvYy5kZXNjcmlwdGlvbiB8fCBkb2MuRGVzY3JpcHRpb24sXHJcbiAgICAgICAgZmlsZUlkOiBkb2MuZmlsZUlkLFxyXG4gICAgICAgIGZpbGVUeXBlOiBkb2MuZmlsZVR5cGUgfHwgZG9jLnR5cGUsXHJcbiAgICAgICAgbmFtZTogZG9jLm5hbWUgfHwgZG9jLnRpdGxlLFxyXG4gICAgICAgIHR5cGU6IGRvYy50eXBlIHx8IGRvYy5maWxlVHlwZSxcclxuICAgICAgICBjcmVhdGVkQXQ6IGRvYy5jcmVhdGVkQXQ/LnRvRGF0ZSA/IGRvYy5jcmVhdGVkQXQudG9EYXRlKCkgOiAoZG9jLmNyZWF0ZWRBdCA/IG5ldyBEYXRlKGRvYy5jcmVhdGVkQXQpIDogdW5kZWZpbmVkKSxcclxuICAgICAgfSkpO1xyXG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtmaXJlc3RvcmVEb2NzLmxlbmd0aH0gZG9jdW1lbnRzIGluIEZpcmVzdG9yZWApO1xyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLndhcm4oXCJFcnJvciBmZXRjaGluZyBmcm9tIEZpcmVzdG9yZTpcIiwgZXJyb3I/Lm1lc3NhZ2UgfHwgXCJVbmtub3duXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEZldGNoIGZyb20gQXBwcyBTY3JpcHQgQVBJXHJcbiAgICBsZXQgYXBpRG9jczogUmF3QXBpRG9jdW1lbnRbXSA9IFtdO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgYXBpVXJsID0gXCIvYXBpL2RvY3VtZW50c1wiO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkZldGNoaW5nIGZyb20gQVBJIHJvdXRlOlwiLCBhcGlVcmwpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGlVcmwsIHtcclxuICAgICAgICBtZXRob2Q6IFwiR0VUXCIsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjYWNoZTogXCJuby1zdG9yZVwiLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKFwiQVBJIFJlc3BvbnNlIFN0YXR1czpcIiwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5zdGF0dXNUZXh0KTtcclxuICAgICAgY29uc29sZS5sb2coXCJBUEkgUmVzcG9uc2UgT0s6XCIsIHJlc3BvbnNlLm9rKTtcclxuXHJcbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJBUEkgUmVzcG9uc2UgRGF0YSBUeXBlOlwiLCBBcnJheS5pc0FycmF5KGRhdGEpID8gXCJhcnJheVwiIDogdHlwZW9mIGRhdGEpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQVBJIFJlc3BvbnNlIERhdGE6XCIsIGRhdGEpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEhhbmRsZSBib3RoIGFycmF5IGFuZCBvYmplY3QgcmVzcG9uc2VzXHJcbiAgICAgICAgYXBpRG9jcyA9IEFycmF5LmlzQXJyYXkoZGF0YSkgXHJcbiAgICAgICAgICA/IGRhdGEgXHJcbiAgICAgICAgICA6IChkYXRhPy5kYXRhIHx8IGRhdGE/LmRvY3VtZW50cyB8fCBkYXRhPy5pdGVtcyB8fCBbXSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7YXBpRG9jcy5sZW5ndGh9IGRvY3VtZW50cyBmcm9tIEFwcHMgU2NyaXB0IEFQSWApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKS5jYXRjaCgoKSA9PiBcIkNvdWxkIG5vdCByZWFkIGVycm9yXCIpO1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBUEkgUm91dGUgRXJyb3IgUmVzcG9uc2U6XCIsIHJlc3BvbnNlLnN0YXR1cywgZXJyb3JUZXh0KTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgZnJvbSBBcHBzIFNjcmlwdCBBUEk6XCIsIGVycm9yPy5tZXNzYWdlIHx8IFwiVW5rbm93blwiKTtcclxuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGRldGFpbHM6XCIsIHtcclxuICAgICAgICBuYW1lOiBlcnJvcj8ubmFtZSxcclxuICAgICAgICBtZXNzYWdlOiBlcnJvcj8ubWVzc2FnZSxcclxuICAgICAgICBzdGFjazogZXJyb3I/LnN0YWNrLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21iaW5lIGJvdGggc291cmNlcyAoRmlyZXN0b3JlIHRha2VzIHByZWNlZGVuY2UgZm9yIGR1cGxpY2F0ZXMgYnkgVVJMKVxyXG4gICAgY29uc3QgYWxsRG9jczogUmF3QXBpRG9jdW1lbnRbXSA9IFsuLi5maXJlc3RvcmVEb2NzLCAuLi5hcGlEb2NzXTtcclxuICAgIFxyXG4gICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXMgYnkgVVJMIChwcmVmZXIgRmlyZXN0b3JlIGVudHJpZXMpXHJcbiAgICBjb25zdCB1bmlxdWVEb2NzID0gbmV3IE1hcDxzdHJpbmcsIFJhd0FwaURvY3VtZW50PigpO1xyXG4gICAgZmlyZXN0b3JlRG9jcy5mb3JFYWNoKGRvYyA9PiB7XHJcbiAgICAgIGlmIChkb2MudXJsKSB1bmlxdWVEb2NzLnNldChkb2MudXJsLCBkb2MpO1xyXG4gICAgfSk7XHJcbiAgICBhcGlEb2NzLmZvckVhY2goZG9jID0+IHtcclxuICAgICAgY29uc3QgdXJsID0gZG9jLlVSTCB8fCBkb2MudXJsO1xyXG4gICAgICBpZiAodXJsICYmICF1bmlxdWVEb2NzLmhhcyh1cmwpKSB7XHJcbiAgICAgICAgdW5pcXVlRG9jcy5zZXQodXJsLCBkb2MpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByYXdEb2NzID0gQXJyYXkuZnJvbSh1bmlxdWVEb2NzLnZhbHVlcygpKTtcclxuXHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocmF3RG9jcykpIHtcclxuICAgICAgY29uc29sZS53YXJuKFwiQ29tYmluZWQgZG9jdW1lbnRzIGlzIG5vdCBhbiBhcnJheVwiKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIPCflKUgTk9STUFMSVpBVElPTiBIQVBQRU5TIEhFUkUgKE9OTFkgT05DRSlcclxuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSByYXdEb2NzXHJcbiAgICAgIC5tYXAoKGRvYzogUmF3QXBpRG9jdW1lbnQpID0+IHtcclxuICAgICAgICAvLyBGaWx0ZXIgb3V0IGRlbGV0ZWQgZG9jdW1lbnRzXHJcbiAgICAgICAgY29uc3QgZGVsZXRlU3RhdHVzID0gZG9jLkRlbGV0ZSB8fCBkb2MuZGVsZXRlIHx8IFwiXCI7XHJcbiAgICAgICAgaWYgKGRlbGV0ZVN0YXR1cy50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09IFwiZGVsZXRlZFwiKSB7XHJcbiAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE5vcm1hbGl6ZSBmaWVsZCBuYW1lcyAtIEFwcHMgU2NyaXB0IHVzZXMgVGl0bGUvVVJMLCB3ZSB1c2UgdGl0bGUvdXJsXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZDogRG9jdW1lbnRJdGVtID0ge1xyXG4gICAgICAgICAgaWQ6IGRvYy5pZCB8fCBkb2MuZmlsZUlkIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICAgIC8vIE1hcCBUaXRsZSAtPiB0aXRsZSAoQXBwcyBTY3JpcHQgZm9ybWF0IHRvIG91ciBmb3JtYXQpXHJcbiAgICAgICAgICB0aXRsZTogZG9jLlRpdGxlIHx8IGRvYy50aXRsZSB8fCBkb2MubmFtZSB8fCBcIlVudGl0bGVkIERvY3VtZW50XCIsXHJcbiAgICAgICAgICAvLyBNYXAgVVJMIC0+IHVybFxyXG4gICAgICAgICAgdXJsOiBkb2MuVVJMIHx8IGRvYy51cmwgfHwgXCJcIixcclxuICAgICAgICAgIC8vIE1hcCBDYXRlZ29yeSAtPiBjYXRlZ29yeVxyXG4gICAgICAgICAgY2F0ZWdvcnk6IGRvYy5DYXRlZ29yeSB8fCBkb2MuY2F0ZWdvcnkgfHwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgLy8gTWFwIFVwbG9hZGVkQnkgLT4gdXBsb2FkZWRCeVxyXG4gICAgICAgICAgdXBsb2FkZWRCeTogZG9jLlVwbG9hZGVkQnkgfHwgZG9jLnVwbG9hZGVkQnkgfHwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgLy8gTWFwIFVwbG9hZGVkRGF0ZSAtPiB1cGxvYWRlZERhdGVcclxuICAgICAgICAgIHVwbG9hZGVkRGF0ZTogZG9jLlVwbG9hZGVkRGF0ZSB8fCBkb2MudXBsb2FkZWREYXRlIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICAgIC8vIE1hcCBEZXNjcmlwdGlvbiAtPiBkZXNjcmlwdGlvblxyXG4gICAgICAgICAgZGVzY3JpcHRpb246IGRvYy5EZXNjcmlwdGlvbiB8fCBkb2MuZGVzY3JpcHRpb24gfHwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgLy8gS2VlcCBmaWxlSWQgYW5kIGZpbGVUeXBlIGFzLWlzXHJcbiAgICAgICAgICBmaWxlSWQ6IGRvYy5maWxlSWQgfHwgdW5kZWZpbmVkLFxyXG4gICAgICAgICAgZmlsZVR5cGU6IGRvYy5maWxlVHlwZSB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgICAvLyBGb3IgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIERvY3VtZW50IGludGVyZmFjZVxyXG4gICAgICAgICAgbmFtZTogZG9jLlRpdGxlIHx8IGRvYy50aXRsZSB8fCBkb2MubmFtZSB8fCBcIlVudGl0bGVkIERvY3VtZW50XCIsXHJcbiAgICAgICAgICB0eXBlOiBkb2MuZmlsZVR5cGUgfHwgZG9jLkNhdGVnb3J5IHx8IGRvYy5jYXRlZ29yeSB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgICAvLyBQYXJzZSBVcGxvYWRlZERhdGUgdG8gRGF0ZSBpZiBhdmFpbGFibGVcclxuICAgICAgICAgIGNyZWF0ZWRBdDogZG9jLlVwbG9hZGVkRGF0ZSBcclxuICAgICAgICAgICAgPyBuZXcgRGF0ZShkb2MuVXBsb2FkZWREYXRlKSBcclxuICAgICAgICAgICAgOiAoZG9jLmNyZWF0ZWRBdCA/IChkb2MuY3JlYXRlZEF0LnRvRGF0ZSA/IGRvYy5jcmVhdGVkQXQudG9EYXRlKCkgOiBuZXcgRGF0ZShkb2MuY3JlYXRlZEF0KSkgOiB1bmRlZmluZWQpLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xyXG4gICAgICB9KVxyXG4gICAgICAuZmlsdGVyKChkb2MpOiBkb2MgaXMgRG9jdW1lbnRJdGVtID0+IGRvYyAhPT0gbnVsbCk7IC8vIFJlbW92ZSBudWxsIGVudHJpZXMgKGRlbGV0ZWQgZG9jdW1lbnRzKVxyXG5cclxuICAgIC8vIFNvcnQgYnkgZGF0ZSAobmV3ZXN0IGZpcnN0KVxyXG4gICAgbm9ybWFsaXplZC5zb3J0KChhLCBiKSA9PiB7XHJcbiAgICAgIGNvbnN0IGFEYXRlID0gYS5jcmVhdGVkQXQ/LmdldFRpbWUoKSB8fCAoYS51cGxvYWRlZERhdGUgPyBuZXcgRGF0ZShhLnVwbG9hZGVkRGF0ZSkuZ2V0VGltZSgpIDogMCk7XHJcbiAgICAgIGNvbnN0IGJEYXRlID0gYi5jcmVhdGVkQXQ/LmdldFRpbWUoKSB8fCAoYi51cGxvYWRlZERhdGUgPyBuZXcgRGF0ZShiLnVwbG9hZGVkRGF0ZSkuZ2V0VGltZSgpIDogMCk7XHJcbiAgICAgIHJldHVybiBiRGF0ZSAtIGFEYXRlOyAvLyBEZXNjZW5kaW5nIG9yZGVyIChuZXdlc3QgZmlyc3QpXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgZG9jdW1lbnRzOlwiLCBlcnJvcik7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBkb2N1bWVudHM6ICR7ZXJyb3I/Lm1lc3NhZ2UgfHwgXCJVbmtub3duIGVycm9yXCJ9YCk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogRGVsZXRlIGEgZG9jdW1lbnQgdmlhIEFwcHMgU2NyaXB0IEFQSVxyXG4gKiBAcGFyYW0gdGl0bGUgLSBEb2N1bWVudCB0aXRsZSAocmVxdWlyZWQgYnkgQXBwcyBTY3JpcHQpXHJcbiAqIEBwYXJhbSB1c2VyRW1haWwgLSBVc2VyIGVtYWlsIGZvciBsb2dnaW5nXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlRG9jdW1lbnQodGl0bGU6IHN0cmluZywgdXNlckVtYWlsOiBzdHJpbmcsIGZpbGVJZD86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiL2FwaS9kb2N1bWVudHNcIiwge1xyXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICBhY3Rpb246IFwiZGVsZXRlRG9jdW1lbnRcIixcclxuICAgICAgICB0aXRsZTogdGl0bGUsXHJcbiAgICAgICAgZmlsZUlkOiBmaWxlSWQsIC8vIEluY2x1ZGUgZmlsZUlkIGlmIGF2YWlsYWJsZSAocmVxdWlyZWQgYnkgQXBwcyBTY3JpcHQpXHJcbiAgICAgICAgdXNlckVtYWlsOiB1c2VyRW1haWwsXHJcbiAgICAgIH0pLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHsgZXJyb3I6IFwiVW5rbm93biBlcnJvclwiIH0pKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCBgRmFpbGVkIHRvIGRlbGV0ZSBkb2N1bWVudDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgIGlmICghZGF0YS5zdWNjZXNzKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yIHx8IFwiRmFpbGVkIHRvIGRlbGV0ZSBkb2N1bWVudFwiKTtcclxuICAgIH1cclxuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZGVsZXRpbmcgZG9jdW1lbnQ6XCIsIGVycm9yKTtcclxuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGRlbGV0ZSBkb2N1bWVudDogJHtlcnJvcj8ubWVzc2FnZSB8fCBcIlVua25vd24gZXJyb3JcIn1gKTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgR29vZ2xlIERyaXZlIHByZXZpZXcgVVJMXHJcbiAqIENvbnZlcnRzIHZhcmlvdXMgR29vZ2xlIERyaXZlIFVSTCBmb3JtYXRzIHRvIHByZXZpZXcgVVJMXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJldmlld1VybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgaWYgKCF1cmwpIHJldHVybiB1cmw7XHJcbiAgXHJcbiAgLy8gRXh0cmFjdCBmaWxlIElEIGZyb20gdmFyaW91cyBHb29nbGUgRHJpdmUgVVJMIGZvcm1hdHNcclxuICBsZXQgZmlsZUlkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICBcclxuICAvLyBQYXR0ZXJuIDE6IC9maWxlL2QvRklMRV9JRC92aWV3IG9yIC9maWxlL2QvRklMRV9JRC9cclxuICBjb25zdCBtYXRjaDEgPSB1cmwubWF0Y2goL1xcL2ZpbGVcXC9kXFwvKFstXFx3XXsyNSx9KS8pO1xyXG4gIGlmIChtYXRjaDEpIGZpbGVJZCA9IG1hdGNoMVsxXTtcclxuICBcclxuICAvLyBQYXR0ZXJuIDI6ID9pZD1GSUxFX0lEIG9yICZpZD1GSUxFX0lEXHJcbiAgaWYgKCFmaWxlSWQpIHtcclxuICAgIGNvbnN0IG1hdGNoMiA9IHVybC5tYXRjaCgvWz8mXWlkPShbLVxcd117MjUsfSkvKTtcclxuICAgIGlmIChtYXRjaDIpIGZpbGVJZCA9IG1hdGNoMlsxXTtcclxuICB9XHJcbiAgXHJcbiAgLy8gUGF0dGVybiAzOiAvdWM/ZXhwb3J0PXZpZXcmaWQ9RklMRV9JRFxyXG4gIGlmICghZmlsZUlkKSB7XHJcbiAgICBjb25zdCBtYXRjaDMgPSB1cmwubWF0Y2goL1xcL3VjXFw/ZXhwb3J0PXZpZXcmaWQ9KFstXFx3XXsyNSx9KS8pO1xyXG4gICAgaWYgKG1hdGNoMykgZmlsZUlkID0gbWF0Y2gzWzFdO1xyXG4gIH1cclxuICBcclxuICAvLyBJZiB3ZSBmb3VuZCBhIGZpbGUgSUQsIHJldHVybiBwcmV2aWV3IFVSTFxyXG4gIGlmIChmaWxlSWQpIHtcclxuICAgIHJldHVybiBgaHR0cHM6Ly9kcml2ZS5nb29nbGUuY29tL2ZpbGUvZC8ke2ZpbGVJZH0vcHJldmlld2A7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIE90aGVyd2lzZSwgcmV0dXJuIG9yaWdpbmFsIFVSTFxyXG4gIHJldHVybiB1cmw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgR29vZ2xlIERyaXZlIGRvd25sb2FkIFVSTFxyXG4gKiBDb252ZXJ0cyB2YXJpb3VzIEdvb2dsZSBEcml2ZSBVUkwgZm9ybWF0cyB0byBkaXJlY3QgZG93bmxvYWQgVVJMXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG93bmxvYWRVcmwodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGlmICghdXJsKSByZXR1cm4gdXJsO1xyXG4gIFxyXG4gIC8vIEV4dHJhY3QgZmlsZSBJRCBmcm9tIHZhcmlvdXMgR29vZ2xlIERyaXZlIFVSTCBmb3JtYXRzXHJcbiAgbGV0IGZpbGVJZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgXHJcbiAgLy8gUGF0dGVybiAxOiAvZmlsZS9kL0ZJTEVfSUQvdmlldyBvciAvZmlsZS9kL0ZJTEVfSUQvXHJcbiAgY29uc3QgbWF0Y2gxID0gdXJsLm1hdGNoKC9cXC9maWxlXFwvZFxcLyhbLVxcd117MjUsfSkvKTtcclxuICBpZiAobWF0Y2gxKSBmaWxlSWQgPSBtYXRjaDFbMV07XHJcbiAgXHJcbiAgLy8gUGF0dGVybiAyOiA/aWQ9RklMRV9JRCBvciAmaWQ9RklMRV9JRFxyXG4gIGlmICghZmlsZUlkKSB7XHJcbiAgICBjb25zdCBtYXRjaDIgPSB1cmwubWF0Y2goL1s/Jl1pZD0oWy1cXHddezI1LH0pLyk7XHJcbiAgICBpZiAobWF0Y2gyKSBmaWxlSWQgPSBtYXRjaDJbMV07XHJcbiAgfVxyXG4gIFxyXG4gIC8vIFBhdHRlcm4gMzogL3VjP2V4cG9ydD12aWV3JmlkPUZJTEVfSURcclxuICBpZiAoIWZpbGVJZCkge1xyXG4gICAgY29uc3QgbWF0Y2gzID0gdXJsLm1hdGNoKC9cXC91Y1xcP2V4cG9ydD12aWV3JmlkPShbLVxcd117MjUsfSkvKTtcclxuICAgIGlmIChtYXRjaDMpIGZpbGVJZCA9IG1hdGNoM1sxXTtcclxuICB9XHJcbiAgXHJcbiAgLy8gSWYgd2UgZm91bmQgYSBmaWxlIElELCByZXR1cm4gZG93bmxvYWQgVVJMXHJcbiAgaWYgKGZpbGVJZCkge1xyXG4gICAgcmV0dXJuIGBodHRwczovL2RyaXZlLmdvb2dsZS5jb20vdWM/ZXhwb3J0PWRvd25sb2FkJmlkPSR7ZmlsZUlkfWA7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIE90aGVyd2lzZSwgcmV0dXJuIG9yaWdpbmFsIFVSTFxyXG4gIHJldHVybiB1cmw7XHJcbn1cclxuXHJcbiJdLCJuYW1lcyI6WyJmZXRjaERvY3VtZW50cyIsImZpcmVzdG9yZURvY3MiLCJnZXREb2N1bWVudHNMaXN0IiwiZnNEb2NzIiwibWFwIiwiZG9jIiwiaWQiLCJ0aXRsZSIsIm5hbWUiLCJ1cmwiLCJVUkwiLCJjYXRlZ29yeSIsIkNhdGVnb3J5IiwidXBsb2FkZWRCeSIsIlVwbG9hZGVkQnkiLCJ1cGxvYWRlZERhdGUiLCJVcGxvYWRlZERhdGUiLCJjcmVhdGVkQXQiLCJ0b0RhdGUiLCJ0b0lTT1N0cmluZyIsInVuZGVmaW5lZCIsImRlc2NyaXB0aW9uIiwiRGVzY3JpcHRpb24iLCJmaWxlSWQiLCJmaWxlVHlwZSIsInR5cGUiLCJEYXRlIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsImVycm9yIiwid2FybiIsIm1lc3NhZ2UiLCJhcGlEb2NzIiwiYXBpVXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJjYWNoZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJvayIsImRhdGEiLCJqc29uIiwiQXJyYXkiLCJpc0FycmF5IiwiZG9jdW1lbnRzIiwiaXRlbXMiLCJlcnJvclRleHQiLCJ0ZXh0IiwiY2F0Y2giLCJzdGFjayIsImFsbERvY3MiLCJ1bmlxdWVEb2NzIiwiTWFwIiwiZm9yRWFjaCIsInNldCIsImhhcyIsInJhd0RvY3MiLCJmcm9tIiwidmFsdWVzIiwibm9ybWFsaXplZCIsImRlbGV0ZVN0YXR1cyIsIkRlbGV0ZSIsImRlbGV0ZSIsInRvU3RyaW5nIiwidG9Mb3dlckNhc2UiLCJUaXRsZSIsImZpbHRlciIsInNvcnQiLCJhIiwiYiIsImFEYXRlIiwiZ2V0VGltZSIsImJEYXRlIiwiRXJyb3IiLCJkZWxldGVEb2N1bWVudCIsInVzZXJFbWFpbCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiYWN0aW9uIiwiZXJyb3JEYXRhIiwic3VjY2VzcyIsImdldFByZXZpZXdVcmwiLCJtYXRjaDEiLCJtYXRjaCIsIm1hdGNoMiIsIm1hdGNoMyIsImdldERvd25sb2FkVXJsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/services/documents.service.ts\n"));

/***/ })

});